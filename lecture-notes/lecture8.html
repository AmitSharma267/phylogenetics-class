<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Botany 563" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lecture 8
## Distance/parsimony methods to estimate phylogenetic trees
### Botany 563

---

class: left, top

# Lecture 8

### Previous class check-up
- We studied the overview of phylogenetic inference and the main challenges

### Learning objectives

At the end of today's session, you will be able to
- explain both algorithms to reconstruct trees: 1) based on distances and 2) based on parsimony
- assess the strenghts and weaknesses of every approach
- use R for tree estimation based on distances or parsinomy

### Pre-class work

- Install R
- Optional readings: HB Ch 5-6, Baum Ch 7-8

---
class: left, top


# Phylogenetic inference

##### Step 1. Choose the criterion to use: distances, parsimony, likelihood

##### Step 2. Search the space of trees until you find the optimum

---
class: left, top


# Phylogenetic methods

|  | Character-based methods | Non-character-based methods | 
| :---:   | :---: | :---:       | 
| Based on an explicit model of evolution | Likelihood methods | Distance methods |
| Not based on an explicit model of evolution | Parsimony methods | |

---
class: left, top

# Distance-based methods

**Goal:** Fit a tree to a matrix of pairwise genetic distances

#### Computing the distances
- For every two sequences, the distance corresponds to the fraction of positions in which the two sequences differ (p-distance)
- The p-distance underestimates the true genetic distance `\(d\)`
- Thus, we do not use the p-distances as the pairwise distances but instead we estimate the number of substitutions that occurred by applying a specific evolutionary model

---
class: left, top

# Distance-based methods


#### Computing the distances


&lt;div style="text-align:center"&gt;&lt;img src="../assets/pics/fig5.2hb.png" width="750"/&gt;&lt;/div&gt;

_Figure 5.2 in HB 5_


---
class: left, top

# Distance-based methods

- We will assume that the genetic distances have been estimated using an appropriate evolutionary model (more on Lectures 9 and 12)
- The main distance-based tree building methods are:
  - cluster analysis
  - minimum evolution
- **Advantage of distance-based methods over parsimony or likelihood:** There are algorithms that produce the optimum tree without having to search the space of trees
  - Pros: You can get the tree in a scalable manner regardless of sample size
  - Cons: 
    - Algorithmic methods tend to be approximations, so they would approximate the optimum tree, but rarely achieve it
    - However, keep in mind that searching the space would not necessarily achieve the optimum either because many times the search is not exhaustive
    

---
class: left, top

## Cluster analysis

- Constructs ultrametric trees (rooted trees in which all the end nodes are equidistant from the root)
- Only possible assuming a **molecular clock**:
  - Zuckerland and Pauling published two fundamental papers on the evolutionary rate of proteins
  - They noticed that the genetic distance of two sequences coding for the same protein on different species seems to increase linearly with divergence time
  - This seems to imply that the rate of evolution for any given protein is constant: existence of a molecular clock
  - This assumption is used for dating the divergences in the tree
  - The molecular clock assumption aligns with the neutral theory of evolution (vs positive selection theory) and implies that deviations from clock-like behavior may reveal adaptive evolution, relazing functional constraints or changes in effective population size
  - How to test the clock hypothesis? HB 11

---
class: left, top

## Cluster analysis

- Constructs ultrametric trees (rooted trees in which all the end nodes are equidistant from the root)
- Only possible assuming a **molecular clock**:

&lt;div style="text-align:center"&gt;&lt;img src="../assets/pics/fig11.1hb.png" width="550"/&gt;&lt;/div&gt;

_Figure 11.1 in HB11_  

---
class: left, top

## Cluster analysis

- Options: 
  - UPGMA: unweighted-pair group methods with arithmetic means
  - WPGMA: weighted-pair group methods with arithmetic means
- Cluster analysis is extremely sensitive to unequal rates in different lineages


#### UPGMA/WPGMA Algorithm

Input: Matrix of pairwise distances

1) Group together the two taxa with smallest distance (say A, B)

2) Compute the distance from AB to every other taxa

WPGMA: `\(d_{(AB)k} = \frac{d_{A,k}+d_{B,k}}{2}\)` (simple average)

UPGMA: `\(d_{(AB)k} = \frac{N_A d_{A,k}+N_B d_{B,k}}{N_A + N_B}\)` (averaged by number of taxa in the cluster)

3) Repeat until all taxa are clustered


**Note:** We are not searching the space of trees here, this is an algorithm that returns a tree that agrees with the distances provided.

---
class: left, top

## Cluster analysis example

**In-class dynamic:** Find the WPGMA tree for the distance matrix below.

&lt;div style="text-align:center"&gt;&lt;img src="../assets/pics/box5.1hb.png" width="550"/&gt;&lt;/div&gt;

_Box 5.1 in HB11_

---
class: left, top

## Minimum evolution
- We want to reconstruct a tree with minimum length
- The length of the tree is inferred from the genetic distances
- It does not reconstruct ultrametric trees, but additive trees
- An additive tree is a tree that satisfies the four-point metric condition: `\(d_{AB}+d_{CD} \leq max(d_{AC}+d_{BD},d_{AD}+d_{BC})\)`
- Additive trees are always a better fit to distances under non-clock-like behavior
- There is an algorithm to estimate the ME tree: neighbor-joining (NJ)
- NJ tree is the same as the ME tree only if distances are additive to begin with, but it has been shown that the NJ tree can be very similar to the ME tree most of the times
- NJ is better that UPGMA/WPGMA under unequal rates of evolution


#### NJ Algorithm

Input: Matrix of pairwise distances

1. Compute the net divergence `\(r\)` for every end node
2. Create a rate-corrected distance matrix: `\(M_{ij} = d_{ij} - \frac{r_i+r_j}{N-2}\)`
3. Define the new node that groups taxa `\(i\)` and `\(j\)` for which `\(M_{ij}\)` is minimal (say A,B)
4. Compute the branch lengths from new node U to A and B
5. Compute new distances from node U to every other end node
6. Repeat the steps


---
class: left, top

## Minimum evolution example

**In-class activity:** Find the NJ tree for the distance matrix below.

&lt;div style="text-align:center"&gt;&lt;img src="../assets/pics/box5.2hb.png" width="350"/&gt;&lt;/div&gt;

_Box 5.2 in HB11_

Note that there are many errors in the book.

**Solution:** See this [youtube video](https://youtu.be/n1BEd05IpEk) with all the steps in the algorithm.


---
class: left, top

# Distance-based methods

### Main conclusions:
- Two steps
  1. genetic distances from a p-distance and a model of evolution
  2. a phylogenetic tree is constructed from the distances
- Distance methods reduce the phylogenetic information to one value per pair of sequences, so many times regarded as inferior compared to character-based methods (less stat power due to the loss of info)
- But unlike parsimony, they rely on an evolution model but the result will depend on which model is chosen (more on Lecture 9 and 12)
- They do not have the model flexibility as likelihood-based models
- Under standard conditions, NJ trees are meant to estimate accurate trees and they are very fast to be estimated
- Aside from the ME algorithm that aims to find the tree that minimizes the tree length, there are other ME algorithms that aim to find the tree that minimize the differences between the genetic distances and the tree distances (called OLS=ordinary least squares): `\(F = \sum_{i,j} (D_{ij}-d_{ij})^2\)` where `\(D_{ij}\)` are the tree distances and `\(d_{ij}\)` are the observed genetic distances


---
class: left, top

# Distance-based methods

### Software: R package _ape_

- _ape_ is one of the most widely used phylogenetic software
- It is an R package and it has a huge variety of functions
- In particular, today we will use it for distance-based tree estimation methods
- [Full documentation](http://ape-package.ird.fr/)
- We will follow this [great tutorial](https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf)

#### In-class group dynamic

**Time:** 10 minutes

**Instructions:** Follow the R commands to obtain a ME tree from the sample data (or your own data!). The commands are listed in the [PDF tutorial]((https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf)) that we are using as guideline or in our reproducible script [notebook-log.md](https://github.com/crsl4/phylogenetics-class/blob/master/exercises/notebook-log.md) or on the following slides.

**Options for you:**

1. "I think that I can follow the pipeline by myself or with a small group of peers": you should join the Congregate room
2. "I think I need more one-on-one help to run the commands": you can stay here in the zoom room

---
class: left, top

# Distance-based methods

### Software: R package _ape_

1) Installing necessary packages:
```r
install.packages("adegenet", dep=TRUE)
install.packages("phangorn", dep=TRUE)
```

2) Loading
```r
library(ape)
library(adegenet)
library(phangorn)
```

3) Loading the sample data
```r
dna &lt;- fasta2DNAbin(file="http://adegenet.r-forge.r-project.org/files/usflu.fasta")
```

---
class: left, top

# Distance-based methods

### Software: R package _ape_

4) Computing the genetic distances. They choose a Tamura
and Nei 1993 model which allows for different rates of transitions and transversions, heterogeneous base frequencies, and between-site variation of the substitution rate.
```r
D &lt;- dist.dna(dna, model="TN93")
```

5) Get the NJ tree
```r
tre &lt;- nj(D)
```

6) Before plotting, we can use the [`ladderize` function](https://rdrr.io/cran/ape/man/ladderize.html) which reorganizes the internal structure of the tree to get the ladderized effect when plotted
```r
tre &lt;- ladderize(tre)
```

---
class: left, top

# Distance-based methods

### Software: R package _ape_

7) We can plot the tree
```r
plot(tre, cex=.6)
title("A simple NJ tree")
```

&lt;div style="text-align:center"&gt;&lt;img src="../assets/pics/nj-tree.png" width="350"/&gt;&lt;/div&gt;

---
class: left, top

# Distance-based methods

### Software: R package _ape_

Main distance functions:
- `nj` (`ape` package): the classical Neighbor-Joining algorithm.
- [`bionj`](https://www.rdocumentation.org/packages/ape/versions/5.4-1/topics/BIONJ) (`ape`): an improved version of Neighbor-Joining: [Gascuel 1997](https://pubmed.ncbi.nlm.nih.gov/9254330/). It uses information on variances of evolutionary distances
- [`fastme.bal` and `fastme.ols`](https://www.rdocumentation.org/packages/ape/versions/5.4-1/topics/FastME) (`ape`): minimum evolution algorithms: [Desper and Gascuel, 2002](https://pubmed.ncbi.nlm.nih.gov/12487758/)
- `hclust` (`stats`): classical hierarchical clustering algorithms including single
linkage, complete linkage, UPGMA, and others.

---
class: left, top

# Distance-based methods

### Homework

Continue the distance-based steps in the [PDF tutorial](https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf) on the same sample data or on your own data.
Don't forget to write down the commands in your personal reproducible script.


---
class: left, top

# Parsimony-based methods

- Character-based data: 4 nucleotides ACGT or 20 aminoacids =&gt; matrix of aligned characters
- It does not rely on models of evolution
- One seeks the tree that minimizes the amount of evolutionary change required to explain the data
- Justification: 
  - Ockham's razor: when two hypothesis provide equally valid explanations for a phenomenon, the simpler one should always be preferred
  - More character-state changes imply a more complex hypothesis because homoplasy (sharing identical character states that cannot be explained by inheritance from a common ancestor) is an _ad hoc_ hypothesis
- The link between parsimony and simplicity is weak: Tuffley and Steel demonstrated that parsimony and likelihood become equivalent under an extremely rich likelihood model that assigns a separate parameter for each character on every branch of the tree (so not necessarily a simple model), but we are not estimating any of the parameters
- Parsimony represents a useful fall back method when model-based methods cannot be used due to computational limitations

---
class: left, top

# Parsimony-based methods

### Assumptions
- Parsimony methods are most effective when rate of evolution is slow, but this is not a necessary assumption
- Parsimony methods can perform well under high rates of evolution as long as there are no pathological inequalities (long-branch attraction: Felsenstein zone)
- The only real assumption of parsimony is independence among characters

---
class: left, top

# Parsimony-based methods

### Methodology

1. Determine the amount of character change required to explain the data by a given tree
2. Search over all possible tree topologies

- We need to be able to calculate the length of a proposed tree which is defined as the amount of character change implied by a most parsimonious reconstruction of internal nodes
- Just as in MSA, we need to have costs for substitutions (equal costs or unequal costs)

**Example:** Evaluate the length of the `((W,Y),(X,Z));` tree given the site:
```
W:G
X:C
Y:A
Z:C
```

- **Full solution:** see this [youtube video](https://youtu.be/lJaFPek3eAc)
- Note that this is only one site! We need to repeat this process for every site and add up the lengths
- More on Newick (parenthetical) format [here](https://en.wikipedia.org/wiki/Newick_format)

---
class: left, top

# Parsimony-based methods

### Methodology

Just as in MSA, we cannot do this by hand and there is a dynamic programming algorithm that helps us (what was dynamic programming?): 
- Fitch algorithm (HB Box 8.2) for equal costs
- Sankoff algorithm (HB Box 8.1) for unequal costs

---
class: left, top

# Parsimony-based methods

### Methodology

#### Fitch algorithm
1) Root the tree in a random place (parsimony score is not affected by the root)

2) Calculate the state-set `\(X_i\)` for each internal node `\(i\)` corresponding the set of states that can be assigned to each node so that the minimum possible length of the subtree can be achieved. Let `\(L(i)\)` and `\(R(i)\)` be the left and rigth child descendant nodes of `\(i\)` respectively.

  2.1) Form the intersection of the two child state sets: `\(X_{L(i)} \cap X_{R(i)}\)`

  2.2) If the intersection is non-empty, set `\(X_i\)` equal to this intersection and the accumulated length for this node as the sum of the accumulated lengths for the two child nodes: `\(s_i=s_{L(i)}+s_{R(i)}\)`

  2.3) If the intersection is empty, let `\(X_i\)` be equal to the union of the two child sets: `\(X_{L(i)} \cup X_{R(i)}\)` and set the accumulated length for this node as the sum of the accumulated lengths for the two child nodes _plus one_: `\(s_i=s_{L(i)}+s_{R(i)}+1\)`
  
---
class: left, top

# Parsimony-based methods

### Methodology
  
**Example:** Evaluate the length of the `((W,Y),(X,Z));` tree given the site:
```
W:G
X:C
Y:A
Z:C
```
using the Fitch algorithm.

- **Full solution:** see this [youtube video](https://youtu.be/bZdEkYyq2hQ)
- **Homework:** Redo the algorithm with different root positions to verify that you get the same length


---
class: left, top


# Phylogenetic inference: Maximum Parsimony (MP) tree

##### Step 1. Evaluate the parsimony score of a given tree (length) with Fitch algorithm

##### Step 2. Search the space of trees until you find the optimum

---
class: left, top

# Parsimony method

### Software: R package _phangorn_

- _phangorn_ is another widely used phylogenetic software
- It is an R package and it has a huge variety of functions
- In particular, today we will use it for parsimony-based tree estimation methods
- [Full documentation](https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.pdf)
- We will follow this [great tutorial](https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf)

#### In-class group dynamic

**Time:** 10 minutes

**Instructions:** Follow the R commands to obtain a MP tree from the sample data (or your own data!). The commands are listed in the [PDF tutorial]((https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf)) that we are using as guideline or in our reproducible script [notebook-log.md](https://github.com/crsl4/phylogenetics-class/blob/master/exercises/notebook-log.md) or on the following slides.

**Options for you:**

1. "I think that I can follow the pipeline by myself or with a small group of peers": you should join the Congregate room
2. "I think I need more one-on-one help to run the commands": you can stay here in the zoom room

---
class: left, top

# Parsimony method

### Software: R package _phangorn_

1) Installing necessary packages (if you have not installed them for the distance section above)
```r
install.packages("adegenet", dep=TRUE)
install.packages("phangorn", dep=TRUE)
```

2) Loading
```r
library(ape)
library(adegenet)
library(phangorn)
```

3) Loading the sample data and convert to phangorn object:
```r
dna &lt;- fasta2DNAbin(file="http://adegenet.r-forge.r-project.org/files/usflu.fasta")
dna2 &lt;- as.phyDat(dna)
```

---
class: left, top

# Parsimony method

### Software: R package _phangorn_

4) We need a starting tree for the search on tree space and compute the parsimony of this tree (422)
```r
tre.ini &lt;- nj(dist.dna(dna,model="raw"))
parsimony(tre.ini, dna2)
```

5) Search for the tree with maximum parsimony:
```r
&gt; tre.pars &lt;- optim.parsimony(tre.ini, dna2)
Final p-score 420 after  2 nni operations
```

6) Plot tree:
```r
plot(tre.pars, cex=0.6)
```

---
class: left, top

# Parsimony-based methods

### Homework

Continue the parsimony steps in the [PDF tutorial](https://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf) on the same sample data or on your own data.
Don't forget to write down the commands in your personal reproducible script.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
